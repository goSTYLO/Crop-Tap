# Task ID: 4
# Title: Implement User Login Endpoint and JWT Generation
# Status: pending
# Dependencies: 3
# Priority: high
# Description: Create the `POST /api/auth/login` endpoint. It will authenticate a user by comparing the provided password with the stored hash and, upon success, issue a JSON Web Token (JWT).
# Details:
In `auth.controller.js`, create a `login` function. Find the user by email. If the user exists, use `bcrypt.compare()` to check if the provided password matches the stored hash. If it matches, generate a JWT using `jsonwebtoken.sign()`. The token payload should include `userId` and `role`. Send the token back to the client in the response body. Use the `JWT_SECRET` from the `.env` file.

# Test Strategy:
Using Postman, send a POST request to `/api/auth/login` with credentials for a user created in the previous task. Verify a 200 OK response containing a JWT string. Test with incorrect credentials to ensure a 401 Unauthorized error is returned.

# Subtasks:
## 1. Install jsonwebtoken and Configure JWT_SECRET Environment Variable [pending]
### Dependencies: None
### Description: Ensure the `jsonwebtoken` library is installed as a project dependency and add a secure secret key to the environment variables file for token signing.
### Details:
Execute 'npm install jsonwebtoken' in the project root. Then, open the `.env` file and add a new entry: `JWT_SECRET=your-secure-random-string`. This secret is critical for securing the tokens.

## 2. Create Login Controller Shell and Implement User Lookup [pending]
### Dependencies: None
### Description: In `src/controllers/auth.controller.js`, create the `login` function. This function will extract the email from the request body and query the database to find the corresponding user.
### Details:
Define `exports.login = async (req, res) => { ... }`. Inside a try-catch block, destructure `email` from `req.body`. Use the Sequelize model `User.findOne({ where: { email: email } })` to retrieve the user. If the user is not found, send a 404 Not Found response.

## 3. Implement Password Verification with bcrypt [pending]
### Dependencies: 4.2
### Description: Within the `login` controller function, after successfully finding a user, compare the plain-text password from the request with the stored hashed password using `bcrypt.compare()`.
### Details:
Import `bcryptjs` at the top of `auth.controller.js`. Inside the `login` function, after the `user` object is fetched, call `const passwordIsValid = bcrypt.compareSync(req.body.password, user.password);`. If `passwordIsValid` is false, return a 401 Unauthorized response with an 'Invalid Password!' message.

## 4. Generate JSON Web Token on Successful Authentication [pending]
### Dependencies: 4.1, 4.3
### Description: Upon successful password verification, generate a JWT. The token's payload should contain the user's ID and role, and it must be signed with the `JWT_SECRET`.
### Details:
Import `jsonwebtoken` at the top of `auth.controller.js`. After the password is validated, create the token: `const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: 86400 });`. The expiration is set to 24 hours.

## 5. Add Login Route and Send Token in Response [pending]
### Dependencies: 4.4
### Description: Define the `POST /api/auth/login` route in `src/routes/auth.routes.js` and connect it to the `login` controller. Finalize the `login` function to send a 200 OK response containing the access token.
### Details:
In `src/routes/auth.routes.js`, add the line `router.post('/login', controller.login);`. Then, in `auth.controller.js`, replace any temporary logging with the final response: `res.status(200).send({ id: user.id, username: user.username, email: user.email, role: user.role, accessToken: token });`.

