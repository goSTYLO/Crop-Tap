# Task ID: 3
# Title: Implement User Registration Endpoint
# Status: pending
# Dependencies: 2
# Priority: high
# Description: Create the `POST /api/auth/register` endpoint to allow new users to sign up. The endpoint should validate input, check for existing users, hash the password, and save the new user to the database.
# Details:
In your `auth.controller.js`, create a `register` function. It should accept `username`, `email`, `password`, and `role` in the request body. Use a `try-catch` block for error handling. Check if a user with the same email already exists. If not, create a new user instance using the `User` model. The `beforeCreate` hook will handle hashing. Respond with a success message and user data (excluding password).

# Test Strategy:
Use Postman or a similar API client to send a POST request to `/api/auth/register` with valid user data. Verify a 201 Created status and the new user's data in the response. Check the database to confirm the user was added with a properly hashed password. Test edge cases like duplicate email registration.

# Subtasks:
## 1. Define the POST /register Route in auth.routes.js [pending]
### Dependencies: None
### Description: Define a new POST route for `/register` within the `auth.routes.js` file. This route will be linked to the `register` controller function which will handle the user registration logic.
### Details:
In the `routes/auth.routes.js` file, import the `register` controller function. Then, add the route definition: `router.post('/register', register);`. This establishes the endpoint for the API.

## 2. Create the `register` Controller Function Shell [pending]
### Dependencies: 3.1
### Description: In `controllers/auth.controller.js`, create an asynchronous `register` function. This function will serve as the handler for the registration logic and must include a `try-catch` block for robust error handling as specified.
### Details:
In `controllers/auth.controller.js`, add `exports.register = async (req, res) => { ... };`. The basic structure should include a `try {} catch (error) {}` block. The catch block should log the error and send a generic 500 server error response.

## 3. Implement Input Validation and Existing User Check [pending]
### Dependencies: 3.2
### Description: Within the `register` controller's `try` block, extract user details from the request body and validate them. Then, query the database to check if a user with the provided email already exists.
### Details:
Destructure `username`, `email`, `password`, and `role` from `req.body`. Check if any are missing. Use the `User` model (`User.findOne({ where: { email } })`) to check for an existing user. If a user is found, return a `400 Bad Request` response with an appropriate message.

## 4. Implement New User Creation Logic [pending]
### Dependencies: 3.3
### Description: After validation confirms the data is valid and the email is unique, create a new user record in the database using the `User` model. The `beforeCreate` hook will handle password hashing automatically.
### Details:
Following the email uniqueness check, call `const user = await User.create({ username, email, password, role });`. This Sequelize method will create the new user entry and trigger the pre-configured model hook to hash the password before saving.

## 5. Format and Send Success Response [pending]
### Dependencies: 3.4
### Description: Upon successful user creation, sanitize the new user object to remove the password hash, and then send a `201 Created` HTTP response containing the clean user data and a success message.
### Details:
The `user` object returned from `User.create` will include the password hash. Create a safe, sanitized version of the user object by excluding the password field. Respond with `res.status(201).json({ success: true, data: sanitizedUser });`.

